<?php

/**
 * FolderApi
 * PHP version 5
 *
 * @category Class
 * @package  BytescalePHP\Client
 * @author   BytescalePHP Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * @bytescale/api
 *
 * Bytescale API
 *
 * OpenAPI spec version: 2.0.0
 * Contact: hello@bytescale.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * BytescalePHP Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace BytescalePHP\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use BytescalePHP\Client\ApiException;
use BytescalePHP\Client\Configuration;
use BytescalePHP\Client\HeaderSelector;
use BytescalePHP\Client\ObjectSerializer;

/**
 * FolderApi Class Doc Comment
 *
 * @category Class
 * @package  BytescalePHP\Client
 * @author   BytescalePHP Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FolderApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation copyFolder
     *
     * Copies a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderRequest $body body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BytescalePHP\Client\Model\AsyncResponse
     */
    public function copyFolder($body, $account_id)
    {
        list($response) = $this->copyFolderWithHttpInfo($body, $account_id);
        return $response;
    }

    /**
     * Operation copyFolderWithHttpInfo
     *
     * Copies a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BytescalePHP\Client\Model\AsyncResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFolderWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\AsyncResponse';
        $request = $this->copyFolderRequest($body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\AsyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFolderAsync
     *
     * Copies a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFolderAsync($body, $account_id)
    {
        return $this->copyFolderAsyncWithHttpInfo($body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFolderAsyncWithHttpInfo
     *
     * Copies a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFolderAsyncWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\AsyncResponse';
        $request = $this->copyFolderRequest($body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFolder'
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyFolderRequest($body, $account_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling copyFolder'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling copyFolder'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/folders/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyFolderBatch
     *
     * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderBatchRequest $body body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BytescalePHP\Client\Model\AsyncResponse
     */
    public function copyFolderBatch($body, $account_id)
    {
        list($response) = $this->copyFolderBatchWithHttpInfo($body, $account_id);
        return $response;
    }

    /**
     * Operation copyFolderBatchWithHttpInfo
     *
     * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderBatchRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BytescalePHP\Client\Model\AsyncResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFolderBatchWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\AsyncResponse';
        $request = $this->copyFolderBatchRequest($body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\AsyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFolderBatchAsync
     *
     * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderBatchRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFolderBatchAsync($body, $account_id)
    {
        return $this->copyFolderBatchAsyncWithHttpInfo($body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFolderBatchAsyncWithHttpInfo
     *
     * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderBatchRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFolderBatchAsyncWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\AsyncResponse';
        $request = $this->copyFolderBatchRequest($body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFolderBatch'
     *
     * @param  \BytescalePHP\Client\Model\CopyFolderBatchRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyFolderBatchRequest($body, $account_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling copyFolderBatch'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling copyFolderBatch'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/folders/copy/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFolder
     *
     * Deletes a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won't be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderRequest $body body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BytescalePHP\Client\Model\AsyncResponse
     */
    public function deleteFolder($body, $account_id)
    {
        list($response) = $this->deleteFolderWithHttpInfo($body, $account_id);
        return $response;
    }

    /**
     * Operation deleteFolderWithHttpInfo
     *
     * Deletes a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won't be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BytescalePHP\Client\Model\AsyncResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFolderWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\AsyncResponse';
        $request = $this->deleteFolderRequest($body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\AsyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFolderAsync
     *
     * Deletes a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won't be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsync($body, $account_id)
    {
        return $this->deleteFolderAsyncWithHttpInfo($body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFolderAsyncWithHttpInfo
     *
     * Deletes a folder asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won't be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsyncWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\AsyncResponse';
        $request = $this->deleteFolderRequest($body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFolder'
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFolderRequest($body, $account_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteFolder'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteFolder'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFolderBatch
     *
     * Deletes multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won't be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderBatchRequest $body body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BytescalePHP\Client\Model\AsyncResponse
     */
    public function deleteFolderBatch($body, $account_id)
    {
        list($response) = $this->deleteFolderBatchWithHttpInfo($body, $account_id);
        return $response;
    }

    /**
     * Operation deleteFolderBatchWithHttpInfo
     *
     * Deletes multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won't be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderBatchRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BytescalePHP\Client\Model\AsyncResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFolderBatchWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\AsyncResponse';
        $request = $this->deleteFolderBatchRequest($body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\AsyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFolderBatchAsync
     *
     * Deletes multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won't be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderBatchRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderBatchAsync($body, $account_id)
    {
        return $this->deleteFolderBatchAsyncWithHttpInfo($body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFolderBatchAsyncWithHttpInfo
     *
     * Deletes multiple folders asynchronously.  You can use ListFolder to preview the operation using the `dryRun` parameter.  *When deleting a folder with external storage:* if the folder at `folderPath` has overridden storage settings (like an AWS S3 bucket), no files will be deleted, regardless of the parameters you pass. Only the mapping will be removed. If the folder at `folderPath` has inherited storage settings but includes subfolders with overridden storage settings, files in those subfolders won't be deleted, regardless of the parameters you pass. In summary, files in folders with overridden storage are never deleted, unless you directly delete a subfolder of such a folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderBatchRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderBatchAsyncWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\AsyncResponse';
        $request = $this->deleteFolderBatchRequest($body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFolderBatch'
     *
     * @param  \BytescalePHP\Client\Model\DeleteFolderBatchRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFolderBatchRequest($body, $account_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteFolderBatch'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteFolderBatch'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/folders/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolderDetails
     *
     * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path folder_path (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BytescalePHP\Client\Model\FolderDetails
     */
    public function getFolderDetails($account_id, $folder_path)
    {
        list($response) = $this->getFolderDetailsWithHttpInfo($account_id, $folder_path);
        return $response;
    }

    /**
     * Operation getFolderDetailsWithHttpInfo
     *
     * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BytescalePHP\Client\Model\FolderDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderDetailsWithHttpInfo($account_id, $folder_path)
    {
        $returnType = '\BytescalePHP\Client\Model\FolderDetails';
        $request = $this->getFolderDetailsRequest($account_id, $folder_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\FolderDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFolderDetailsAsync
     *
     * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderDetailsAsync($account_id, $folder_path)
    {
        return $this->getFolderDetailsAsyncWithHttpInfo($account_id, $folder_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderDetailsAsyncWithHttpInfo
     *
     * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderDetailsAsyncWithHttpInfo($account_id, $folder_path)
    {
        $returnType = '\BytescalePHP\Client\Model\FolderDetails';
        $request = $this->getFolderDetailsRequest($account_id, $folder_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolderDetails'
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFolderDetailsRequest($account_id, $folder_path)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getFolderDetails'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling getFolderDetails'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path, null);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFolder
     *
     * Lists the folder's contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the next request.  Pagination is complete when the response includes `isPaginationComplete=true`.
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path folder_path (required)
     * @param  \BytescalePHP\Client\Model\ListFolderCursor $cursor cursor (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderDryRun $dry_run dry_run (optional)
     * @param  \BytescalePHP\Client\Model\IncludeFiles $include_files include_files (optional)
     * @param  \BytescalePHP\Client\Model\IncludeOverriddenStorage $include_overridden_storage include_overridden_storage (optional)
     * @param  \BytescalePHP\Client\Model\IncludePhysicalFolders $include_physical_folders include_physical_folders (optional)
     * @param  \BytescalePHP\Client\Model\IncludeVirtualFolders $include_virtual_folders include_virtual_folders (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderItemLimit $limit limit (optional)
     * @param  \BytescalePHP\Client\Model\IterateFolderRecursively $recursive recursive (optional)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BytescalePHP\Client\Model\ListFolderResponse
     */
    public function listFolder($account_id, $folder_path, $cursor = null, $dry_run = null, $include_files = null, $include_overridden_storage = null, $include_physical_folders = null, $include_virtual_folders = null, $limit = null, $recursive = null)
    {
        list($response) = $this->listFolderWithHttpInfo($account_id, $folder_path, $cursor, $dry_run, $include_files, $include_overridden_storage, $include_physical_folders, $include_virtual_folders, $limit, $recursive);
        return $response;
    }

    /**
     * Operation listFolderWithHttpInfo
     *
     * Lists the folder's contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the next request.  Pagination is complete when the response includes `isPaginationComplete=true`.
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path (required)
     * @param  \BytescalePHP\Client\Model\ListFolderCursor $cursor (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderDryRun $dry_run (optional)
     * @param  \BytescalePHP\Client\Model\IncludeFiles $include_files (optional)
     * @param  \BytescalePHP\Client\Model\IncludeOverriddenStorage $include_overridden_storage (optional)
     * @param  \BytescalePHP\Client\Model\IncludePhysicalFolders $include_physical_folders (optional)
     * @param  \BytescalePHP\Client\Model\IncludeVirtualFolders $include_virtual_folders (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderItemLimit $limit (optional)
     * @param  \BytescalePHP\Client\Model\IterateFolderRecursively $recursive (optional)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BytescalePHP\Client\Model\ListFolderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFolderWithHttpInfo($account_id, $folder_path, $cursor = null, $dry_run = null, $include_files = null, $include_overridden_storage = null, $include_physical_folders = null, $include_virtual_folders = null, $limit = null, $recursive = null)
    {
        $returnType = '\BytescalePHP\Client\Model\ListFolderResponse';
        $request = $this->listFolderRequest($account_id, $folder_path, $cursor, $dry_run, $include_files, $include_overridden_storage, $include_physical_folders, $include_virtual_folders, $limit, $recursive);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\ListFolderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listFolderAsync
     *
     * Lists the folder's contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the next request.  Pagination is complete when the response includes `isPaginationComplete=true`.
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path (required)
     * @param  \BytescalePHP\Client\Model\ListFolderCursor $cursor (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderDryRun $dry_run (optional)
     * @param  \BytescalePHP\Client\Model\IncludeFiles $include_files (optional)
     * @param  \BytescalePHP\Client\Model\IncludeOverriddenStorage $include_overridden_storage (optional)
     * @param  \BytescalePHP\Client\Model\IncludePhysicalFolders $include_physical_folders (optional)
     * @param  \BytescalePHP\Client\Model\IncludeVirtualFolders $include_virtual_folders (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderItemLimit $limit (optional)
     * @param  \BytescalePHP\Client\Model\IterateFolderRecursively $recursive (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFolderAsync($account_id, $folder_path, $cursor = null, $dry_run = null, $include_files = null, $include_overridden_storage = null, $include_physical_folders = null, $include_virtual_folders = null, $limit = null, $recursive = null)
    {
        return $this->listFolderAsyncWithHttpInfo($account_id, $folder_path, $cursor, $dry_run, $include_files, $include_overridden_storage, $include_physical_folders, $include_virtual_folders, $limit, $recursive)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFolderAsyncWithHttpInfo
     *
     * Lists the folder's contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the next request.  Pagination is complete when the response includes `isPaginationComplete=true`.
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path (required)
     * @param  \BytescalePHP\Client\Model\ListFolderCursor $cursor (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderDryRun $dry_run (optional)
     * @param  \BytescalePHP\Client\Model\IncludeFiles $include_files (optional)
     * @param  \BytescalePHP\Client\Model\IncludeOverriddenStorage $include_overridden_storage (optional)
     * @param  \BytescalePHP\Client\Model\IncludePhysicalFolders $include_physical_folders (optional)
     * @param  \BytescalePHP\Client\Model\IncludeVirtualFolders $include_virtual_folders (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderItemLimit $limit (optional)
     * @param  \BytescalePHP\Client\Model\IterateFolderRecursively $recursive (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFolderAsyncWithHttpInfo($account_id, $folder_path, $cursor = null, $dry_run = null, $include_files = null, $include_overridden_storage = null, $include_physical_folders = null, $include_virtual_folders = null, $limit = null, $recursive = null)
    {
        $returnType = '\BytescalePHP\Client\Model\ListFolderResponse';
        $request = $this->listFolderRequest($account_id, $folder_path, $cursor, $dry_run, $include_files, $include_overridden_storage, $include_physical_folders, $include_virtual_folders, $limit, $recursive);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFolder'
     *
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     * @param  \BytescalePHP\Client\Model\FolderPath $folder_path (required)
     * @param  \BytescalePHP\Client\Model\ListFolderCursor $cursor (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderDryRun $dry_run (optional)
     * @param  \BytescalePHP\Client\Model\IncludeFiles $include_files (optional)
     * @param  \BytescalePHP\Client\Model\IncludeOverriddenStorage $include_overridden_storage (optional)
     * @param  \BytescalePHP\Client\Model\IncludePhysicalFolders $include_physical_folders (optional)
     * @param  \BytescalePHP\Client\Model\IncludeVirtualFolders $include_virtual_folders (optional)
     * @param  \BytescalePHP\Client\Model\ListFolderItemLimit $limit (optional)
     * @param  \BytescalePHP\Client\Model\IterateFolderRecursively $recursive (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listFolderRequest($account_id, $folder_path, $cursor = null, $dry_run = null, $include_files = null, $include_overridden_storage = null, $include_physical_folders = null, $include_virtual_folders = null, $limit = null, $recursive = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling listFolder'
            );
        }
        // verify the required parameter 'folder_path' is set
        if ($folder_path === null || (is_array($folder_path) && count($folder_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_path when calling listFolder'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/folders/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }
        // query params
        if ($dry_run !== null) {
            $queryParams['dryRun'] = ObjectSerializer::toQueryValue($dry_run, null);
        }
        // query params
        if ($folder_path !== null) {
            $queryParams['folderPath'] = ObjectSerializer::toQueryValue($folder_path, null);
        }
        // query params
        if ($include_files !== null) {
            $queryParams['includeFiles'] = ObjectSerializer::toQueryValue($include_files, null);
        }
        // query params
        if ($include_overridden_storage !== null) {
            $queryParams['includeOverriddenStorage'] = ObjectSerializer::toQueryValue($include_overridden_storage, null);
        }
        // query params
        if ($include_physical_folders !== null) {
            $queryParams['includePhysicalFolders'] = ObjectSerializer::toQueryValue($include_physical_folders, null);
        }
        // query params
        if ($include_virtual_folders !== null) {
            $queryParams['includeVirtualFolders'] = ObjectSerializer::toQueryValue($include_virtual_folders, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($recursive !== null) {
            $queryParams['recursive'] = ObjectSerializer::toQueryValue($recursive, null);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putFolder
     *
     * Creates or updates the folder specified by the `folderPath`.  If the folder's ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don't need to create folders before uploading files to them.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\PutFolderRequest $body body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BytescalePHP\Client\Model\FolderDetails
     */
    public function putFolder($body, $account_id)
    {
        list($response) = $this->putFolderWithHttpInfo($body, $account_id);
        return $response;
    }

    /**
     * Operation putFolderWithHttpInfo
     *
     * Creates or updates the folder specified by the `folderPath`.  If the folder's ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don't need to create folders before uploading files to them.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\PutFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \BytescalePHP\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BytescalePHP\Client\Model\FolderDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFolderWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\FolderDetails';
        $request = $this->putFolderRequest($body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string', 'integer', 'bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\FolderDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BytescalePHP\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFolderAsync
     *
     * Creates or updates the folder specified by the `folderPath`.  If the folder's ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don't need to create folders before uploading files to them.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\PutFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFolderAsync($body, $account_id)
    {
        return $this->putFolderAsyncWithHttpInfo($body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFolderAsyncWithHttpInfo
     *
     * Creates or updates the folder specified by the `folderPath`.  If the folder's ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don't need to create folders before uploading files to them.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \BytescalePHP\Client\Model\PutFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFolderAsyncWithHttpInfo($body, $account_id)
    {
        $returnType = '\BytescalePHP\Client\Model\FolderDetails';
        $request = $this->putFolderRequest($body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putFolder'
     *
     * @param  \BytescalePHP\Client\Model\PutFolderRequest $body (required)
     * @param  \BytescalePHP\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putFolderRequest($body, $account_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling putFolder'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling putFolder'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/folders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
