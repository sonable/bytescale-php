<?php
/**
 * FileApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * @bytescale/api
 *
 * Bytescale API
 *
 * OpenAPI spec version: 2.0.0
 * Contact: hello@bytescale.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * FileApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FileApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation copyFile
     *
     * Copies a file synchronously.
     *
     * @param  \Swagger\Client\Model\CopyFileRequest $body body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CopyFileResponse
     */
    public function copyFile($body, $account_id)
    {
        list($response) = $this->copyFileWithHttpInfo($body, $account_id);
        return $response;
    }

    /**
     * Operation copyFileWithHttpInfo
     *
     * Copies a file synchronously.
     *
     * @param  \Swagger\Client\Model\CopyFileRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CopyFileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFileWithHttpInfo($body, $account_id)
    {
        $returnType = '\Swagger\Client\Model\CopyFileResponse';
        $request = $this->copyFileRequest($body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CopyFileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFileAsync
     *
     * Copies a file synchronously.
     *
     * @param  \Swagger\Client\Model\CopyFileRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsync($body, $account_id)
    {
        return $this->copyFileAsyncWithHttpInfo($body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFileAsyncWithHttpInfo
     *
     * Copies a file synchronously.
     *
     * @param  \Swagger\Client\Model\CopyFileRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsyncWithHttpInfo($body, $account_id)
    {
        $returnType = '\Swagger\Client\Model\CopyFileResponse';
        $request = $this->copyFileRequest($body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFile'
     *
     * @param  \Swagger\Client\Model\CopyFileRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyFileRequest($body, $account_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling copyFile'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling copyFile'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/files/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyFileBatch
     *
     * Copies multiple files asynchronously.
     *
     * @param  \Swagger\Client\Model\CopyFileBatchRequest $body body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AsyncResponse
     */
    public function copyFileBatch($body, $account_id)
    {
        list($response) = $this->copyFileBatchWithHttpInfo($body, $account_id);
        return $response;
    }

    /**
     * Operation copyFileBatchWithHttpInfo
     *
     * Copies multiple files asynchronously.
     *
     * @param  \Swagger\Client\Model\CopyFileBatchRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AsyncResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFileBatchWithHttpInfo($body, $account_id)
    {
        $returnType = '\Swagger\Client\Model\AsyncResponse';
        $request = $this->copyFileBatchRequest($body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AsyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFileBatchAsync
     *
     * Copies multiple files asynchronously.
     *
     * @param  \Swagger\Client\Model\CopyFileBatchRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileBatchAsync($body, $account_id)
    {
        return $this->copyFileBatchAsyncWithHttpInfo($body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFileBatchAsyncWithHttpInfo
     *
     * Copies multiple files asynchronously.
     *
     * @param  \Swagger\Client\Model\CopyFileBatchRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileBatchAsyncWithHttpInfo($body, $account_id)
    {
        $returnType = '\Swagger\Client\Model\AsyncResponse';
        $request = $this->copyFileBatchRequest($body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFileBatch'
     *
     * @param  \Swagger\Client\Model\CopyFileBatchRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function copyFileBatchRequest($body, $account_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling copyFileBatch'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling copyFileBatch'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/files/copy/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFile
     *
     * Deletes a file synchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path file_path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFile($account_id, $file_path)
    {
        $this->deleteFileWithHttpInfo($account_id, $file_path);
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * Deletes a file synchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($account_id, $file_path)
    {
        $returnType = '';
        $request = $this->deleteFileRequest($account_id, $file_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileAsync
     *
     * Deletes a file synchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync($account_id, $file_path)
    {
        return $this->deleteFileAsyncWithHttpInfo($account_id, $file_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * Deletes a file synchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsyncWithHttpInfo($account_id, $file_path)
    {
        $returnType = '';
        $request = $this->deleteFileRequest($account_id, $file_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFileRequest($account_id, $file_path)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteFile'
            );
        }
        // verify the required parameter 'file_path' is set
        if ($file_path === null || (is_array($file_path) && count($file_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_path when calling deleteFile'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file_path !== null) {
            $queryParams['filePath'] = ObjectSerializer::toQueryValue($file_path, null);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFileBatch
     *
     * Deletes multiple files asynchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \Swagger\Client\Model\DeleteFileBatchRequest $body body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AsyncResponse
     */
    public function deleteFileBatch($body, $account_id)
    {
        list($response) = $this->deleteFileBatchWithHttpInfo($body, $account_id);
        return $response;
    }

    /**
     * Operation deleteFileBatchWithHttpInfo
     *
     * Deletes multiple files asynchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \Swagger\Client\Model\DeleteFileBatchRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AsyncResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileBatchWithHttpInfo($body, $account_id)
    {
        $returnType = '\Swagger\Client\Model\AsyncResponse';
        $request = $this->deleteFileBatchRequest($body, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AsyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileBatchAsync
     *
     * Deletes multiple files asynchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \Swagger\Client\Model\DeleteFileBatchRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileBatchAsync($body, $account_id)
    {
        return $this->deleteFileBatchAsyncWithHttpInfo($body, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileBatchAsyncWithHttpInfo
     *
     * Deletes multiple files asynchronously.  Requires a `secret_*` API key. Alternatively, you can use a `public_*` API key and JWT-based auth.
     *
     * @param  \Swagger\Client\Model\DeleteFileBatchRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileBatchAsyncWithHttpInfo($body, $account_id)
    {
        $returnType = '\Swagger\Client\Model\AsyncResponse';
        $request = $this->deleteFileBatchRequest($body, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFileBatch'
     *
     * @param  \Swagger\Client\Model\DeleteFileBatchRequest $body (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFileBatchRequest($body, $account_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling deleteFileBatch'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling deleteFileBatch'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/files/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadFile
     *
     * Downloads a file in its original/unprocessed state.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path file_path (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function downloadFile($account_id, $file_path, $cache = null, $cache_ttl = null, $version = null)
    {
        list($response) = $this->downloadFileWithHttpInfo($account_id, $file_path, $cache, $cache_ttl, $version);
        return $response;
    }

    /**
     * Operation downloadFileWithHttpInfo
     *
     * Downloads a file in its original/unprocessed state.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFileWithHttpInfo($account_id, $file_path, $cache = null, $cache_ttl = null, $version = null)
    {
        $returnType = 'string';
        $request = $this->downloadFileRequest($account_id, $file_path, $cache, $cache_ttl, $version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadFileAsync
     *
     * Downloads a file in its original/unprocessed state.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileAsync($account_id, $file_path, $cache = null, $cache_ttl = null, $version = null)
    {
        return $this->downloadFileAsyncWithHttpInfo($account_id, $file_path, $cache, $cache_ttl, $version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadFileAsyncWithHttpInfo
     *
     * Downloads a file in its original/unprocessed state.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileAsyncWithHttpInfo($account_id, $file_path, $cache = null, $cache_ttl = null, $version = null)
    {
        $returnType = 'string';
        $request = $this->downloadFileRequest($account_id, $file_path, $cache, $cache_ttl, $version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadFile'
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadFileRequest($account_id, $file_path, $cache = null, $cache_ttl = null, $version = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling downloadFile'
            );
        }
        // verify the required parameter 'file_path' is set
        if ($file_path === null || (is_array($file_path) && count($file_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_path when calling downloadFile'
            );
        }

        $resourcePath = '/{accountId}/raw{filePath}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($cache !== null) {
            $queryParams['cache'] = ObjectSerializer::toQueryValue($cache, null);
        }
        // query params
        if ($cache_ttl !== null) {
            $queryParams['cache_ttl'] = ObjectSerializer::toQueryValue($cache_ttl, null);
        }
        // query params
        if ($version !== null) {
            $queryParams['version'] = ObjectSerializer::toQueryValue($version, null);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($file_path !== null) {
            $resourcePath = str_replace(
                '{' . 'filePath' . '}',
                ObjectSerializer::toPathValue($file_path),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileDetails
     *
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path file_path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FileDetails
     */
    public function getFileDetails($account_id, $file_path)
    {
        list($response) = $this->getFileDetailsWithHttpInfo($account_id, $file_path);
        return $response;
    }

    /**
     * Operation getFileDetailsWithHttpInfo
     *
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FileDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileDetailsWithHttpInfo($account_id, $file_path)
    {
        $returnType = '\Swagger\Client\Model\FileDetails';
        $request = $this->getFileDetailsRequest($account_id, $file_path);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FileDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileDetailsAsync
     *
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileDetailsAsync($account_id, $file_path)
    {
        return $this->getFileDetailsAsyncWithHttpInfo($account_id, $file_path)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileDetailsAsyncWithHttpInfo
     *
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileDetailsAsyncWithHttpInfo($account_id, $file_path)
    {
        $returnType = '\Swagger\Client\Model\FileDetails';
        $request = $this->getFileDetailsRequest($account_id, $file_path);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileDetails'
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFileDetailsRequest($account_id, $file_path)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getFileDetails'
            );
        }
        // verify the required parameter 'file_path' is set
        if ($file_path === null || (is_array($file_path) && count($file_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_path when calling getFileDetails'
            );
        }

        $resourcePath = '/v2/accounts/{accountId}/files/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($file_path !== null) {
            $queryParams['filePath'] = ObjectSerializer::toQueryValue($file_path, null);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation processFile
     *
     * Processes a file and returns the result.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationArtifactPath $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cache_only Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cache_perm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#x27;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#x27;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#x27;s settings. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function processFile($account_id, $file_path, $transformation, $artifact = null, $cache = null, $cache_only = null, $cache_perm = null, $cache_ttl = null, $transformation_params = null, $version = null)
    {
        list($response) = $this->processFileWithHttpInfo($account_id, $file_path, $transformation, $artifact, $cache, $cache_only, $cache_perm, $cache_ttl, $transformation_params, $version);
        return $response;
    }

    /**
     * Operation processFileWithHttpInfo
     *
     * Processes a file and returns the result.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationArtifactPath $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cache_only Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cache_perm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#x27;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#x27;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#x27;s settings. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function processFileWithHttpInfo($account_id, $file_path, $transformation, $artifact = null, $cache = null, $cache_only = null, $cache_perm = null, $cache_ttl = null, $transformation_params = null, $version = null)
    {
        $returnType = 'string';
        $request = $this->processFileRequest($account_id, $file_path, $transformation, $artifact, $cache, $cache_only, $cache_perm, $cache_ttl, $transformation_params, $version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation processFileAsync
     *
     * Processes a file and returns the result.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationArtifactPath $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cache_only Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cache_perm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#x27;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#x27;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#x27;s settings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processFileAsync($account_id, $file_path, $transformation, $artifact = null, $cache = null, $cache_only = null, $cache_perm = null, $cache_ttl = null, $transformation_params = null, $version = null)
    {
        return $this->processFileAsyncWithHttpInfo($account_id, $file_path, $transformation, $artifact, $cache, $cache_only, $cache_perm, $cache_ttl, $transformation_params, $version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation processFileAsyncWithHttpInfo
     *
     * Processes a file and returns the result.
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationArtifactPath $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cache_only Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cache_perm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#x27;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#x27;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#x27;s settings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processFileAsyncWithHttpInfo($account_id, $file_path, $transformation, $artifact = null, $cache = null, $cache_only = null, $cache_perm = null, $cache_ttl = null, $transformation_params = null, $version = null)
    {
        $returnType = 'string';
        $request = $this->processFileRequest($account_id, $file_path, $transformation, $artifact, $cache, $cache_only, $cache_perm, $cache_ttl, $transformation_params, $version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'processFile'
     *
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationArtifactPath $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cache_only Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cache_perm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#x27;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cache_ttl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#x27;s device and in the Bytescale CDN&#x27;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#x27;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#x27;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#x27;s settings. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function processFileRequest($account_id, $file_path, $transformation, $artifact = null, $cache = null, $cache_only = null, $cache_perm = null, $cache_ttl = null, $transformation_params = null, $version = null)
    {
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling processFile'
            );
        }
        // verify the required parameter 'file_path' is set
        if ($file_path === null || (is_array($file_path) && count($file_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_path when calling processFile'
            );
        }
        // verify the required parameter 'transformation' is set
        if ($transformation === null || (is_array($transformation) && count($transformation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transformation when calling processFile'
            );
        }

        $resourcePath = '/{accountId}/{transformation}{filePath}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($artifact !== null) {
            $queryParams['artifact'] = ObjectSerializer::toQueryValue($artifact, null);
        }
        // query params
        if ($cache !== null) {
            $queryParams['cache'] = ObjectSerializer::toQueryValue($cache, null);
        }
        // query params
        if ($cache_only !== null) {
            $queryParams['cache_only'] = ObjectSerializer::toQueryValue($cache_only, null);
        }
        // query params
        if ($cache_perm !== null) {
            $queryParams['cache_perm'] = ObjectSerializer::toQueryValue($cache_perm, null);
        }
        // query params
        if ($cache_ttl !== null) {
            $queryParams['cache_ttl'] = ObjectSerializer::toQueryValue($cache_ttl, null);
        }
        // query params
        if ($transformation_params !== null) {
            $queryParams['transformationParams'] = ObjectSerializer::toQueryValue($transformation_params, null);
        }
        // query params
        if ($version !== null) {
            $queryParams['version'] = ObjectSerializer::toQueryValue($version, null);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($file_path !== null) {
            $resourcePath = str_replace(
                '{' . 'filePath' . '}',
                ObjectSerializer::toPathValue($file_path),
                $resourcePath
            );
        }
        // path params
        if ($transformation !== null) {
            $resourcePath = str_replace(
                '{' . 'transformation' . '}',
                ObjectSerializer::toPathValue($transformation),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation processFileAndSave
     *
     * Processes a file and saves the result.
     *
     * @param  \Swagger\Client\Model\ProcessFileAndSaveRequest $body File output parameters. (required)
     * @param  \Swagger\Client\Model\AccountId $account_id account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProcessFileAndSaveResponse
     */
    public function processFileAndSave($body, $account_id, $file_path, $transformation, $transformation_params = null)
    {
        list($response) = $this->processFileAndSaveWithHttpInfo($body, $account_id, $file_path, $transformation, $transformation_params);
        return $response;
    }

    /**
     * Operation processFileAndSaveWithHttpInfo
     *
     * Processes a file and saves the result.
     *
     * @param  \Swagger\Client\Model\ProcessFileAndSaveRequest $body File output parameters. (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProcessFileAndSaveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function processFileAndSaveWithHttpInfo($body, $account_id, $file_path, $transformation, $transformation_params = null)
    {
        $returnType = '\Swagger\Client\Model\ProcessFileAndSaveResponse';
        $request = $this->processFileAndSaveRequest($body, $account_id, $file_path, $transformation, $transformation_params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProcessFileAndSaveResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation processFileAndSaveAsync
     *
     * Processes a file and saves the result.
     *
     * @param  \Swagger\Client\Model\ProcessFileAndSaveRequest $body File output parameters. (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processFileAndSaveAsync($body, $account_id, $file_path, $transformation, $transformation_params = null)
    {
        return $this->processFileAndSaveAsyncWithHttpInfo($body, $account_id, $file_path, $transformation, $transformation_params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation processFileAndSaveAsyncWithHttpInfo
     *
     * Processes a file and saves the result.
     *
     * @param  \Swagger\Client\Model\ProcessFileAndSaveRequest $body File output parameters. (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processFileAndSaveAsyncWithHttpInfo($body, $account_id, $file_path, $transformation, $transformation_params = null)
    {
        $returnType = '\Swagger\Client\Model\ProcessFileAndSaveResponse';
        $request = $this->processFileAndSaveRequest($body, $account_id, $file_path, $transformation, $transformation_params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'processFileAndSave'
     *
     * @param  \Swagger\Client\Model\ProcessFileAndSaveRequest $body File output parameters. (required)
     * @param  \Swagger\Client\Model\AccountId $account_id (required)
     * @param  \Swagger\Client\Model\FilePath $file_path (required)
     * @param  \Swagger\Client\Model\TransformationUrlSlug $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Swagger\Client\Model\TransformationParams $transformation_params Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function processFileAndSaveRequest($body, $account_id, $file_path, $transformation, $transformation_params = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling processFileAndSave'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling processFileAndSave'
            );
        }
        // verify the required parameter 'file_path' is set
        if ($file_path === null || (is_array($file_path) && count($file_path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_path when calling processFileAndSave'
            );
        }
        // verify the required parameter 'transformation' is set
        if ($transformation === null || (is_array($transformation) && count($transformation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transformation when calling processFileAndSave'
            );
        }

        $resourcePath = '/{accountId}/save/{transformation}{filePath}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($transformation_params !== null) {
            $queryParams['transformationParams'] = ObjectSerializer::toQueryValue($transformation_params, null);
        }

        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($file_path !== null) {
            $resourcePath = str_replace(
                '{' . 'filePath' . '}',
                ObjectSerializer::toPathValue($file_path),
                $resourcePath
            );
        }
        // path params
        if ($transformation !== null) {
            $resourcePath = str_replace(
                '{' . 'transformation' . '}',
                ObjectSerializer::toPathValue($transformation),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
