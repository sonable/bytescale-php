<?php
/**
 * FileApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Bytescale
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * @bytescale/api
 *
 * Bytescale API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@bytescale.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.3.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Bytescale\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Bytescale\ApiException;
use Bytescale\Configuration;
use Bytescale\HeaderSelector;
use Bytescale\ObjectSerializer;

/**
 * FileApi Class Doc Comment
 *
 * @category Class
 * @package  Bytescale
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FileApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'copyFile' => [
            'application/json',
        ],
        'copyFileBatch' => [
            'application/json',
        ],
        'deleteFile' => [
            'application/json',
        ],
        'deleteFileBatch' => [
            'application/json',
        ],
        'downloadFile' => [
            'application/json',
        ],
        'getFileDetails' => [
            'application/json',
        ],
        'processFile' => [
            'application/json',
        ],
        'processFileAndSave' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation copyFile
     *
     * Copies a file synchronously.
     *
     * @param  string $accountId accountId (required)
     * @param  \Bytescale\Model\CopyFileRequest $copyFileRequest copyFileRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFile'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Bytescale\Model\CopyFileResponse|\Bytescale\Model\ErrorResponse
     */
    public function copyFile($accountId, $copyFileRequest, string $contentType = self::contentTypes['copyFile'][0])
    {
        list($response) = $this->copyFileWithHttpInfo($accountId, $copyFileRequest, $contentType);
        return $response;
    }

    /**
     * Operation copyFileWithHttpInfo
     *
     * Copies a file synchronously.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\CopyFileRequest $copyFileRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFile'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Bytescale\Model\CopyFileResponse|\Bytescale\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFileWithHttpInfo($accountId, $copyFileRequest, string $contentType = self::contentTypes['copyFile'][0])
    {
        $request = $this->copyFileRequest($accountId, $copyFileRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bytescale\Model\CopyFileResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\CopyFileResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\CopyFileResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Bytescale\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bytescale\Model\CopyFileResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\CopyFileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFileAsync
     *
     * Copies a file synchronously.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\CopyFileRequest $copyFileRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsync($accountId, $copyFileRequest, string $contentType = self::contentTypes['copyFile'][0])
    {
        return $this->copyFileAsyncWithHttpInfo($accountId, $copyFileRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFileAsyncWithHttpInfo
     *
     * Copies a file synchronously.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\CopyFileRequest $copyFileRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsyncWithHttpInfo($accountId, $copyFileRequest, string $contentType = self::contentTypes['copyFile'][0])
    {
        $returnType = '\Bytescale\Model\CopyFileResponse';
        $request = $this->copyFileRequest($accountId, $copyFileRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFile'
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\CopyFileRequest $copyFileRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function copyFileRequest($accountId, $copyFileRequest, string $contentType = self::contentTypes['copyFile'][0])
    {

        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling copyFile'
            );
        }
        if (strlen($accountId) > 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.copyFile, must be smaller than or equal to 7.');
        }
        if (strlen($accountId) < 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.copyFile, must be bigger than or equal to 7.');
        }
        if (!preg_match("/^[1-9A-HJ-NP-Za-km-z]*$/", $accountId)) {
            throw new \InvalidArgumentException("invalid value for \"accountId\" when calling FileApi.copyFile, must conform to the pattern /^[1-9A-HJ-NP-Za-km-z]*$/.");
        }
        
        // verify the required parameter 'copyFileRequest' is set
        if ($copyFileRequest === null || (is_array($copyFileRequest) && count($copyFileRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $copyFileRequest when calling copyFile'
            );
        }


        $resourcePath = '/v2/accounts/{accountId}/files/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($copyFileRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($copyFileRequest));
            } else {
                $httpBody = $copyFileRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyFileBatch
     *
     * Copies multiple files asynchronously.
     *
     * @param  string $accountId accountId (required)
     * @param  \Bytescale\Model\CopyFileBatchRequest $copyFileBatchRequest copyFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileBatch'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Bytescale\Model\AsyncResponse|\Bytescale\Model\ErrorResponse|\Bytescale\Model\ErrorResponse
     */
    public function copyFileBatch($accountId, $copyFileBatchRequest, string $contentType = self::contentTypes['copyFileBatch'][0])
    {
        list($response) = $this->copyFileBatchWithHttpInfo($accountId, $copyFileBatchRequest, $contentType);
        return $response;
    }

    /**
     * Operation copyFileBatchWithHttpInfo
     *
     * Copies multiple files asynchronously.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\CopyFileBatchRequest $copyFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileBatch'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Bytescale\Model\AsyncResponse|\Bytescale\Model\ErrorResponse|\Bytescale\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFileBatchWithHttpInfo($accountId, $copyFileBatchRequest, string $contentType = self::contentTypes['copyFileBatch'][0])
    {
        $request = $this->copyFileBatchRequest($accountId, $copyFileBatchRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bytescale\Model\AsyncResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\AsyncResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\AsyncResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Bytescale\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\Bytescale\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bytescale\Model\AsyncResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\AsyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation copyFileBatchAsync
     *
     * Copies multiple files asynchronously.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\CopyFileBatchRequest $copyFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileBatchAsync($accountId, $copyFileBatchRequest, string $contentType = self::contentTypes['copyFileBatch'][0])
    {
        return $this->copyFileBatchAsyncWithHttpInfo($accountId, $copyFileBatchRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFileBatchAsyncWithHttpInfo
     *
     * Copies multiple files asynchronously.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\CopyFileBatchRequest $copyFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileBatchAsyncWithHttpInfo($accountId, $copyFileBatchRequest, string $contentType = self::contentTypes['copyFileBatch'][0])
    {
        $returnType = '\Bytescale\Model\AsyncResponse';
        $request = $this->copyFileBatchRequest($accountId, $copyFileBatchRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFileBatch'
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\CopyFileBatchRequest $copyFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function copyFileBatchRequest($accountId, $copyFileBatchRequest, string $contentType = self::contentTypes['copyFileBatch'][0])
    {

        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling copyFileBatch'
            );
        }
        if (strlen($accountId) > 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.copyFileBatch, must be smaller than or equal to 7.');
        }
        if (strlen($accountId) < 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.copyFileBatch, must be bigger than or equal to 7.');
        }
        if (!preg_match("/^[1-9A-HJ-NP-Za-km-z]*$/", $accountId)) {
            throw new \InvalidArgumentException("invalid value for \"accountId\" when calling FileApi.copyFileBatch, must conform to the pattern /^[1-9A-HJ-NP-Za-km-z]*$/.");
        }
        
        // verify the required parameter 'copyFileBatchRequest' is set
        if ($copyFileBatchRequest === null || (is_array($copyFileBatchRequest) && count($copyFileBatchRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $copyFileBatchRequest when calling copyFileBatch'
            );
        }


        $resourcePath = '/v2/accounts/{accountId}/files/copy/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($copyFileBatchRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($copyFileBatchRequest));
            } else {
                $httpBody = $copyFileBatchRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFile
     *
     * Deletes a file synchronously.  Requires a &#x60;secret_*&#x60; API key. Alternatively, you can use a &#x60;public_*&#x60; API key and JWT-based auth.
     *
     * @param  string $accountId accountId (required)
     * @param  string $filePath filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFile($accountId, $filePath, string $contentType = self::contentTypes['deleteFile'][0])
    {
        $this->deleteFileWithHttpInfo($accountId, $filePath, $contentType);
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * Deletes a file synchronously.  Requires a &#x60;secret_*&#x60; API key. Alternatively, you can use a &#x60;public_*&#x60; API key and JWT-based auth.
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($accountId, $filePath, string $contentType = self::contentTypes['deleteFile'][0])
    {
        $request = $this->deleteFileRequest($accountId, $filePath, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileAsync
     *
     * Deletes a file synchronously.  Requires a &#x60;secret_*&#x60; API key. Alternatively, you can use a &#x60;public_*&#x60; API key and JWT-based auth.
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync($accountId, $filePath, string $contentType = self::contentTypes['deleteFile'][0])
    {
        return $this->deleteFileAsyncWithHttpInfo($accountId, $filePath, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * Deletes a file synchronously.  Requires a &#x60;secret_*&#x60; API key. Alternatively, you can use a &#x60;public_*&#x60; API key and JWT-based auth.
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsyncWithHttpInfo($accountId, $filePath, string $contentType = self::contentTypes['deleteFile'][0])
    {
        $returnType = '';
        $request = $this->deleteFileRequest($accountId, $filePath, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFileRequest($accountId, $filePath, string $contentType = self::contentTypes['deleteFile'][0])
    {

        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling deleteFile'
            );
        }
        if (strlen($accountId) > 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.deleteFile, must be smaller than or equal to 7.');
        }
        if (strlen($accountId) < 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.deleteFile, must be bigger than or equal to 7.');
        }
        if (!preg_match("/^[1-9A-HJ-NP-Za-km-z]*$/", $accountId)) {
            throw new \InvalidArgumentException("invalid value for \"accountId\" when calling FileApi.deleteFile, must conform to the pattern /^[1-9A-HJ-NP-Za-km-z]*$/.");
        }
        
        // verify the required parameter 'filePath' is set
        if ($filePath === null || (is_array($filePath) && count($filePath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filePath when calling deleteFile'
            );
        }
        if (strlen($filePath) > 512) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.deleteFile, must be smaller than or equal to 512.');
        }
        if (strlen($filePath) < 1) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.deleteFile, must be bigger than or equal to 1.');
        }
        if (!preg_match("/^\/.*$/", $filePath)) {
            throw new \InvalidArgumentException("invalid value for \"filePath\" when calling FileApi.deleteFile, must conform to the pattern /^\/.*$/.");
        }
        

        $resourcePath = '/v2/accounts/{accountId}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filePath,
            'filePath', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFileBatch
     *
     * Deletes multiple files asynchronously.  Requires a &#x60;secret_*&#x60; API key. Alternatively, you can use a &#x60;public_*&#x60; API key and JWT-based auth.
     *
     * @param  string $accountId accountId (required)
     * @param  \Bytescale\Model\DeleteFileBatchRequest $deleteFileBatchRequest deleteFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileBatch'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Bytescale\Model\AsyncResponse|\Bytescale\Model\ErrorResponse|\Bytescale\Model\ErrorResponse
     */
    public function deleteFileBatch($accountId, $deleteFileBatchRequest, string $contentType = self::contentTypes['deleteFileBatch'][0])
    {
        list($response) = $this->deleteFileBatchWithHttpInfo($accountId, $deleteFileBatchRequest, $contentType);
        return $response;
    }

    /**
     * Operation deleteFileBatchWithHttpInfo
     *
     * Deletes multiple files asynchronously.  Requires a &#x60;secret_*&#x60; API key. Alternatively, you can use a &#x60;public_*&#x60; API key and JWT-based auth.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\DeleteFileBatchRequest $deleteFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileBatch'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Bytescale\Model\AsyncResponse|\Bytescale\Model\ErrorResponse|\Bytescale\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileBatchWithHttpInfo($accountId, $deleteFileBatchRequest, string $contentType = self::contentTypes['deleteFileBatch'][0])
    {
        $request = $this->deleteFileBatchRequest($accountId, $deleteFileBatchRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bytescale\Model\AsyncResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\AsyncResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\AsyncResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Bytescale\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\Bytescale\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bytescale\Model\AsyncResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\AsyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileBatchAsync
     *
     * Deletes multiple files asynchronously.  Requires a &#x60;secret_*&#x60; API key. Alternatively, you can use a &#x60;public_*&#x60; API key and JWT-based auth.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\DeleteFileBatchRequest $deleteFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileBatchAsync($accountId, $deleteFileBatchRequest, string $contentType = self::contentTypes['deleteFileBatch'][0])
    {
        return $this->deleteFileBatchAsyncWithHttpInfo($accountId, $deleteFileBatchRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileBatchAsyncWithHttpInfo
     *
     * Deletes multiple files asynchronously.  Requires a &#x60;secret_*&#x60; API key. Alternatively, you can use a &#x60;public_*&#x60; API key and JWT-based auth.
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\DeleteFileBatchRequest $deleteFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileBatchAsyncWithHttpInfo($accountId, $deleteFileBatchRequest, string $contentType = self::contentTypes['deleteFileBatch'][0])
    {
        $returnType = '\Bytescale\Model\AsyncResponse';
        $request = $this->deleteFileBatchRequest($accountId, $deleteFileBatchRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFileBatch'
     *
     * @param  string $accountId (required)
     * @param  \Bytescale\Model\DeleteFileBatchRequest $deleteFileBatchRequest (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFileBatchRequest($accountId, $deleteFileBatchRequest, string $contentType = self::contentTypes['deleteFileBatch'][0])
    {

        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling deleteFileBatch'
            );
        }
        if (strlen($accountId) > 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.deleteFileBatch, must be smaller than or equal to 7.');
        }
        if (strlen($accountId) < 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.deleteFileBatch, must be bigger than or equal to 7.');
        }
        if (!preg_match("/^[1-9A-HJ-NP-Za-km-z]*$/", $accountId)) {
            throw new \InvalidArgumentException("invalid value for \"accountId\" when calling FileApi.deleteFileBatch, must conform to the pattern /^[1-9A-HJ-NP-Za-km-z]*$/.");
        }
        
        // verify the required parameter 'deleteFileBatchRequest' is set
        if ($deleteFileBatchRequest === null || (is_array($deleteFileBatchRequest) && count($deleteFileBatchRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deleteFileBatchRequest when calling deleteFileBatch'
            );
        }


        $resourcePath = '/v2/accounts/{accountId}/files/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deleteFileBatchRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deleteFileBatchRequest));
            } else {
                $httpBody = $deleteFileBatchRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadFile
     *
     * Downloads a file in its original/unprocessed state.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId accountId (required)
     * @param  string $filePath filePath (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFile'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadFile($accountId, $filePath, $cache = null, $cacheTtl = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['downloadFile'][0])
    {
        list($response) = $this->downloadFileWithHttpInfo($accountId, $filePath, $cache, $cacheTtl, $version, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation downloadFileWithHttpInfo
     *
     * Downloads a file in its original/unprocessed state.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFile'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFileWithHttpInfo($accountId, $filePath, $cache = null, $cacheTtl = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['downloadFile'][0])
    {
        $request = $this->downloadFileRequest($accountId, $filePath, $cache, $cacheTtl, $version, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadFileAsync
     *
     * Downloads a file in its original/unprocessed state.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileAsync($accountId, $filePath, $cache = null, $cacheTtl = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['downloadFile'][0])
    {
        return $this->downloadFileAsyncWithHttpInfo($accountId, $filePath, $cache, $cacheTtl, $version, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadFileAsyncWithHttpInfo
     *
     * Downloads a file in its original/unprocessed state.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileAsyncWithHttpInfo($accountId, $filePath, $cache = null, $cacheTtl = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['downloadFile'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->downloadFileRequest($accountId, $filePath, $cache, $cacheTtl, $version, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadFile'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  bool $cache Specifies whether to cache the raw file in the Bytescale CDN.  Default: true (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the file will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  string $version Downloads the latest version of your file (if you have overwritten it) when added to the URL with a unique value.    The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.    You only need to provide and update this value if/when you overwrite your file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['downloadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadFileRequest($accountId, $filePath, $cache = null, $cacheTtl = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['downloadFile'][0])
    {

        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling downloadFile'
            );
        }
        if (strlen($accountId) > 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.downloadFile, must be smaller than or equal to 7.');
        }
        if (strlen($accountId) < 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.downloadFile, must be bigger than or equal to 7.');
        }
        if (!preg_match("/^[1-9A-HJ-NP-Za-km-z]*$/", $accountId)) {
            throw new \InvalidArgumentException("invalid value for \"accountId\" when calling FileApi.downloadFile, must conform to the pattern /^[1-9A-HJ-NP-Za-km-z]*$/.");
        }
        
        // verify the required parameter 'filePath' is set
        if ($filePath === null || (is_array($filePath) && count($filePath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filePath when calling downloadFile'
            );
        }
        if (strlen($filePath) > 512) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.downloadFile, must be smaller than or equal to 512.');
        }
        if (strlen($filePath) < 1) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.downloadFile, must be bigger than or equal to 1.');
        }
        if (!preg_match("/^\/.*$/", $filePath)) {
            throw new \InvalidArgumentException("invalid value for \"filePath\" when calling FileApi.downloadFile, must conform to the pattern /^\/.*$/.");
        }
        




        $resourcePath = '/{accountId}/raw{filePath}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cache,
            'cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cacheTtl,
            'cache_ttl', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }
        // path params
        if ($filePath !== null) {
            $resourcePath = str_replace(
                '{' . 'filePath' . '}',
                ObjectSerializer::toPathValue($filePath),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsFordownloadFile();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation downloadFile
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsFordownloadFile(): array
    {
        return [
            [
                "url" => "https://upcdn.io",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation getFileDetails
     *
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     *
     * @param  string $accountId accountId (required)
     * @param  string $filePath filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileDetails'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Bytescale\Model\FileDetails|\Bytescale\Model\ErrorResponse
     */
    public function getFileDetails($accountId, $filePath, string $contentType = self::contentTypes['getFileDetails'][0])
    {
        list($response) = $this->getFileDetailsWithHttpInfo($accountId, $filePath, $contentType);
        return $response;
    }

    /**
     * Operation getFileDetailsWithHttpInfo
     *
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileDetails'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Bytescale\Model\FileDetails|\Bytescale\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileDetailsWithHttpInfo($accountId, $filePath, string $contentType = self::contentTypes['getFileDetails'][0])
    {
        $request = $this->getFileDetailsRequest($accountId, $filePath, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bytescale\Model\FileDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\FileDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\FileDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Bytescale\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\ErrorResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bytescale\Model\FileDetails';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\FileDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileDetailsAsync
     *
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileDetailsAsync($accountId, $filePath, string $contentType = self::contentTypes['getFileDetails'][0])
    {
        return $this->getFileDetailsAsyncWithHttpInfo($accountId, $filePath, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileDetailsAsyncWithHttpInfo
     *
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileDetailsAsyncWithHttpInfo($accountId, $filePath, string $contentType = self::contentTypes['getFileDetails'][0])
    {
        $returnType = '\Bytescale\Model\FileDetails';
        $request = $this->getFileDetailsRequest($accountId, $filePath, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileDetails'
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileDetails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileDetailsRequest($accountId, $filePath, string $contentType = self::contentTypes['getFileDetails'][0])
    {

        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling getFileDetails'
            );
        }
        if (strlen($accountId) > 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.getFileDetails, must be smaller than or equal to 7.');
        }
        if (strlen($accountId) < 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.getFileDetails, must be bigger than or equal to 7.');
        }
        if (!preg_match("/^[1-9A-HJ-NP-Za-km-z]*$/", $accountId)) {
            throw new \InvalidArgumentException("invalid value for \"accountId\" when calling FileApi.getFileDetails, must conform to the pattern /^[1-9A-HJ-NP-Za-km-z]*$/.");
        }
        
        // verify the required parameter 'filePath' is set
        if ($filePath === null || (is_array($filePath) && count($filePath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filePath when calling getFileDetails'
            );
        }
        if (strlen($filePath) > 512) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.getFileDetails, must be smaller than or equal to 512.');
        }
        if (strlen($filePath) < 1) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.getFileDetails, must be bigger than or equal to 1.');
        }
        if (!preg_match("/^\/.*$/", $filePath)) {
            throw new \InvalidArgumentException("invalid value for \"filePath\" when calling FileApi.getFileDetails, must conform to the pattern /^\/.*$/.");
        }
        

        $resourcePath = '/v2/accounts/{accountId}/files/details';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filePath,
            'filePath', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation processFile
     *
     * Processes a file and returns the result.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId accountId (required)
     * @param  string $filePath filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  string $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cacheOnly Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cachePerm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#39;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#39;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#39;s settings. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFile'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function processFile($accountId, $filePath, $transformation, $artifact = null, $cache = null, $cacheOnly = null, $cachePerm = null, $cacheTtl = null, $transformationParams = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFile'][0])
    {
        list($response) = $this->processFileWithHttpInfo($accountId, $filePath, $transformation, $artifact, $cache, $cacheOnly, $cachePerm, $cacheTtl, $transformationParams, $version, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation processFileWithHttpInfo
     *
     * Processes a file and returns the result.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  string $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cacheOnly Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cachePerm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#39;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#39;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#39;s settings. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFile'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function processFileWithHttpInfo($accountId, $filePath, $transformation, $artifact = null, $cache = null, $cacheOnly = null, $cachePerm = null, $cacheTtl = null, $transformationParams = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFile'][0])
    {
        $request = $this->processFileRequest($accountId, $filePath, $transformation, $artifact, $cache, $cacheOnly, $cachePerm, $cacheTtl, $transformationParams, $version, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation processFileAsync
     *
     * Processes a file and returns the result.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  string $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cacheOnly Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cachePerm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#39;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#39;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#39;s settings. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processFileAsync($accountId, $filePath, $transformation, $artifact = null, $cache = null, $cacheOnly = null, $cachePerm = null, $cacheTtl = null, $transformationParams = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFile'][0])
    {
        return $this->processFileAsyncWithHttpInfo($accountId, $filePath, $transformation, $artifact, $cache, $cacheOnly, $cachePerm, $cacheTtl, $transformationParams, $version, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation processFileAsyncWithHttpInfo
     *
     * Processes a file and returns the result.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  string $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cacheOnly Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cachePerm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#39;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#39;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#39;s settings. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processFileAsyncWithHttpInfo($accountId, $filePath, $transformation, $artifact = null, $cache = null, $cacheOnly = null, $cachePerm = null, $cacheTtl = null, $transformationParams = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFile'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->processFileRequest($accountId, $filePath, $transformation, $artifact, $cache, $cacheOnly, $cachePerm, $cacheTtl, $transformationParams, $version, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'processFile'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  string $artifact Some transformations output multiple files, called artifacts.  You can download each individual transformation artifact by specifying its path with this parameter (optional)
     * @param  bool $cache Specifies whether to cache the transformed result.  If set to &#x60;false&#x60; the transformation will be executed on every request.  *Recommendation:* instead of disabling the cache, a more performant solution is to use the &#x60;version&#x60; parameter and to increment it each time you require an updated result.  Default: true (optional)
     * @param  bool $cacheOnly Only serve transformations from the cache; do not perform new transformations on cache miss.  If &#x60;true&#x60;, then if the transformation result does not exist in the cache, a 404 will be returned. No transformations will be performed.  If &#x60;false&#x60;, then if the transformation result does not exist in the cache, a new transformation will be performed to produce the result.  Default: &#x60;false&#x60; (optional)
     * @param  string $cachePerm Specifies whether to cache the transformed result in the Bytescale CDN perma-cache.  Perma-caching works by storing your file permanently, or until a manual cache purge is performed.  When &#x60;cache&#x3D;false&#x60; this parameter is automatically set to &#x60;false&#x60;.  When &#x60;cache_perm&#x3D;auto&#x60; the perma-cache will only be used for files that take more than 1000ms to process.  When the perma-cache is used, approximately 200ms of latency is added to the initial request. Thereafter, files will be served from the Bytescale CDN&#39;s edge cache or perma-cache, so will have minimal latency.  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  float $cacheTtl Specifies the maximum amount of time, in seconds, the transformed result will be cached on the user&#39;s device and in the Bytescale CDN&#39;s edge cache.  If the file is perma-cached, then the file will not be reprocessed on edge cache misses.  If the file is not perma-cached, then the file will be reprocessed on edge cache misses.  For more information on perma-caching, see: &#x60;cache_perm&#x60;  Default: Please refer to your account&#39;s default cache settings in the Bytescale Dashboard. (optional)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  string $version Add this parameter and increment its value to force the file to be reprocessed.  The Bytescale CDN caches files based on the full URL (including the querystring), meaning this parameter is useful when dealing with changes made to transformation presets. By contrast, File Processing APIs (like the Image Processing API) shouldn&#39;t ever require this parameter, since the URL/querystring naturally changes each time you adjust a parameter, causing a cache miss and the file to be reprocessed with the new querystring parameters.  The value of the &#x60;version&#x60; parameter can be anything, e.g. an incremental number, a timestamp, etc.  You only need to provide and update this value if/when you make changes to a transformation preset&#39;s settings. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function processFileRequest($accountId, $filePath, $transformation, $artifact = null, $cache = null, $cacheOnly = null, $cachePerm = null, $cacheTtl = null, $transformationParams = null, $version = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFile'][0])
    {

        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling processFile'
            );
        }
        if (strlen($accountId) > 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.processFile, must be smaller than or equal to 7.');
        }
        if (strlen($accountId) < 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.processFile, must be bigger than or equal to 7.');
        }
        if (!preg_match("/^[1-9A-HJ-NP-Za-km-z]*$/", $accountId)) {
            throw new \InvalidArgumentException("invalid value for \"accountId\" when calling FileApi.processFile, must conform to the pattern /^[1-9A-HJ-NP-Za-km-z]*$/.");
        }
        
        // verify the required parameter 'filePath' is set
        if ($filePath === null || (is_array($filePath) && count($filePath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filePath when calling processFile'
            );
        }
        if (strlen($filePath) > 512) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.processFile, must be smaller than or equal to 512.');
        }
        if (strlen($filePath) < 1) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.processFile, must be bigger than or equal to 1.');
        }
        if (!preg_match("/^\/.*$/", $filePath)) {
            throw new \InvalidArgumentException("invalid value for \"filePath\" when calling FileApi.processFile, must conform to the pattern /^\/.*$/.");
        }
        
        // verify the required parameter 'transformation' is set
        if ($transformation === null || (is_array($transformation) && count($transformation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transformation when calling processFile'
            );
        }
        if (strlen($transformation) > 100) {
            throw new \InvalidArgumentException('invalid length for "$transformation" when calling FileApi.processFile, must be smaller than or equal to 100.');
        }
        if (strlen($transformation) < 1) {
            throw new \InvalidArgumentException('invalid length for "$transformation" when calling FileApi.processFile, must be bigger than or equal to 1.');
        }
        if (!preg_match("/^[a-zA-Z0-9-_+=\\x40~;%][a-zA-Z0-9-_.+=\\x40~;%]*$/", $transformation)) {
            throw new \InvalidArgumentException("invalid value for \"transformation\" when calling FileApi.processFile, must conform to the pattern /^[a-zA-Z0-9-_+=\\x40~;%][a-zA-Z0-9-_.+=\\x40~;%]*$/.");
        }
        
        if ($artifact !== null && !preg_match("/^\/(?:((?!\\.*[\/\\\\]).)((?![\/\\\\]\\.*[\/\\\\]).)*)?$/", $artifact)) {
            throw new \InvalidArgumentException("invalid value for \"artifact\" when calling FileApi.processFile, must conform to the pattern /^\/(?:((?!\\.*[\/\\\\]).)((?![\/\\\\]\\.*[\/\\\\]).)*)?$/.");
        }
        







        $resourcePath = '/{accountId}/{transformation}{filePath}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $artifact,
            'artifact', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cache,
            'cache', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cacheOnly,
            'cache_only', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cachePerm,
            'cache_perm', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cacheTtl,
            'cache_ttl', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transformationParams,
            'transformationParams', // param base name
            'OneOfMapArray', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }
        // path params
        if ($filePath !== null) {
            $resourcePath = str_replace(
                '{' . 'filePath' . '}',
                ObjectSerializer::toPathValue($filePath),
                $resourcePath
            );
        }
        // path params
        if ($transformation !== null) {
            $resourcePath = str_replace(
                '{' . 'transformation' . '}',
                ObjectSerializer::toPathValue($transformation),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForprocessFile();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation processFile
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForprocessFile(): array
    {
        return [
            [
                "url" => "https://upcdn.io",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Operation processFileAndSave
     *
     * Processes a file and saves the result.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId accountId (required)
     * @param  string $filePath filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Bytescale\Model\ProcessFileAndSaveRequest $processFileAndSaveRequest File output parameters. (required)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFileAndSave'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Bytescale\Model\ProcessFileAndSaveResponse
     */
    public function processFileAndSave($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFileAndSave'][0])
    {
        list($response) = $this->processFileAndSaveWithHttpInfo($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation processFileAndSaveWithHttpInfo
     *
     * Processes a file and saves the result.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Bytescale\Model\ProcessFileAndSaveRequest $processFileAndSaveRequest File output parameters. (required)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFileAndSave'] to see the possible values for this operation
     *
     * @throws \Bytescale\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Bytescale\Model\ProcessFileAndSaveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function processFileAndSaveWithHttpInfo($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFileAndSave'][0])
    {
        $request = $this->processFileAndSaveRequest($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bytescale\Model\ProcessFileAndSaveResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bytescale\Model\ProcessFileAndSaveResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bytescale\Model\ProcessFileAndSaveResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bytescale\Model\ProcessFileAndSaveResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bytescale\Model\ProcessFileAndSaveResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation processFileAndSaveAsync
     *
     * Processes a file and saves the result.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Bytescale\Model\ProcessFileAndSaveRequest $processFileAndSaveRequest File output parameters. (required)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFileAndSave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processFileAndSaveAsync($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFileAndSave'][0])
    {
        return $this->processFileAndSaveAsyncWithHttpInfo($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation processFileAndSaveAsyncWithHttpInfo
     *
     * Processes a file and saves the result.
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Bytescale\Model\ProcessFileAndSaveRequest $processFileAndSaveRequest File output parameters. (required)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFileAndSave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processFileAndSaveAsyncWithHttpInfo($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFileAndSave'][0])
    {
        $returnType = '\Bytescale\Model\ProcessFileAndSaveResponse';
        $request = $this->processFileAndSaveRequest($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'processFileAndSave'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: https://upcdn.io
     *
     * @param  string $accountId (required)
     * @param  string $filePath (required)
     * @param  string $transformation The name of the File Processing API (e.g. &#x60;image&#x60;, &#x60;video&#x60;, &#x60;audio&#x60;) or transformation preset (created in the Bytescale Dashboard) to use when processing the file. (required)
     * @param  \Bytescale\Model\ProcessFileAndSaveRequest $processFileAndSaveRequest File output parameters. (required)
     * @param  TransformationParams $transformationParams Parameters to submit to the File Processing API (e.g. the Image Processing API).  Please see the documentation for each File Processing API to determine which values can appear here:  - https://www.bytescale.com/docs/image-processing-api - https://www.bytescale.com/docs/video-processing-api - https://www.bytescale.com/docs/audio-processing-api - https://www.bytescale.com/docs/archive-processing-api (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processFileAndSave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function processFileAndSaveRequest($accountId, $filePath, $transformation, $processFileAndSaveRequest, $transformationParams = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['processFileAndSave'][0])
    {

        // verify the required parameter 'accountId' is set
        if ($accountId === null || (is_array($accountId) && count($accountId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accountId when calling processFileAndSave'
            );
        }
        if (strlen($accountId) > 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.processFileAndSave, must be smaller than or equal to 7.');
        }
        if (strlen($accountId) < 7) {
            throw new \InvalidArgumentException('invalid length for "$accountId" when calling FileApi.processFileAndSave, must be bigger than or equal to 7.');
        }
        if (!preg_match("/^[1-9A-HJ-NP-Za-km-z]*$/", $accountId)) {
            throw new \InvalidArgumentException("invalid value for \"accountId\" when calling FileApi.processFileAndSave, must conform to the pattern /^[1-9A-HJ-NP-Za-km-z]*$/.");
        }
        
        // verify the required parameter 'filePath' is set
        if ($filePath === null || (is_array($filePath) && count($filePath) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $filePath when calling processFileAndSave'
            );
        }
        if (strlen($filePath) > 512) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.processFileAndSave, must be smaller than or equal to 512.');
        }
        if (strlen($filePath) < 1) {
            throw new \InvalidArgumentException('invalid length for "$filePath" when calling FileApi.processFileAndSave, must be bigger than or equal to 1.');
        }
        if (!preg_match("/^\/.*$/", $filePath)) {
            throw new \InvalidArgumentException("invalid value for \"filePath\" when calling FileApi.processFileAndSave, must conform to the pattern /^\/.*$/.");
        }
        
        // verify the required parameter 'transformation' is set
        if ($transformation === null || (is_array($transformation) && count($transformation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transformation when calling processFileAndSave'
            );
        }
        if (strlen($transformation) > 100) {
            throw new \InvalidArgumentException('invalid length for "$transformation" when calling FileApi.processFileAndSave, must be smaller than or equal to 100.');
        }
        if (strlen($transformation) < 1) {
            throw new \InvalidArgumentException('invalid length for "$transformation" when calling FileApi.processFileAndSave, must be bigger than or equal to 1.');
        }
        if (!preg_match("/^[a-zA-Z0-9-_+=\\x40~;%][a-zA-Z0-9-_.+=\\x40~;%]*$/", $transformation)) {
            throw new \InvalidArgumentException("invalid value for \"transformation\" when calling FileApi.processFileAndSave, must conform to the pattern /^[a-zA-Z0-9-_+=\\x40~;%][a-zA-Z0-9-_.+=\\x40~;%]*$/.");
        }
        
        // verify the required parameter 'processFileAndSaveRequest' is set
        if ($processFileAndSaveRequest === null || (is_array($processFileAndSaveRequest) && count($processFileAndSaveRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $processFileAndSaveRequest when calling processFileAndSave'
            );
        }



        $resourcePath = '/{accountId}/save/{transformation}{filePath}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transformationParams,
            'transformationParams', // param base name
            'OneOfMapArray', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($accountId !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($accountId),
                $resourcePath
            );
        }
        // path params
        if ($filePath !== null) {
            $resourcePath = str_replace(
                '{' . 'filePath' . '}',
                ObjectSerializer::toPathValue($filePath),
                $resourcePath
            );
        }
        // path params
        if ($transformation !== null) {
            $resourcePath = str_replace(
                '{' . 'transformation' . '}',
                ObjectSerializer::toPathValue($transformation),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($processFileAndSaveRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($processFileAndSaveRequest));
            } else {
                $httpBody = $processFileAndSaveRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForprocessFileAndSave();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation processFileAndSave
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForprocessFileAndSave(): array
    {
        return [
            [
                "url" => "https://upcdn.io",
                "description" => "No description provided",
            ]
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
